# README

##  Binary-Exploit-Visualization
This project is based on the open-source tool [angr](https://github.com/angr/angr). We implement a system named BveView, which is based on the record-and-replay method. We record the information of the exploit process by ptrace mechanism and replay the exploit process through the angr tool. During repeated replays, we analyze and capture abnormal behaviors which are closely related to the key points of the exploit to show the exploit process. We will get a visual report finally.

## Description
### System overview
<img src="./pic/system_overview.png" width = "475" height = "289"  />

## Setup Environments
+ Install the pypy3.7 first. For example:
```bash
wget https://downloads.python.org/pypy/pypy3.7-v7.3.3-linux64.tar.bz2
tar jxvf pypy3.7-v7.3.3-linux64.tar.bz2
mv pypy3.7-v7.3.3-linux64 /usr/lib/
export PATH=/usr/lib/pypy3.7-v7.3.3-linux64/bin:$PATH
```
+ Run the script file [setup.sh](./setup.sh) to install the python environment.

## Usage

### Before Record
Disable the aslr mechanism. Run the script in the root directory.
```bash
./set-aslr.sh off
```

### Record the Exploit Process
In order to disable the delay loading of link library, set environment variable:
```
LD_BIND_NOW=1
```
If you run the target program in cmd:
```bash
ffmpeg -i http://127.0.0.1:12345
```
change to
```bash*
LD_BIND_NOW=1 ./record_ptrace ./ffmpeg -i http://127.0.0.1:12345
```

If you exploit the through a script, the example origin exploit script is below:
```python
# path: ./test/fastbin
from pwn import *

p = process('./fast', env={"LD_BIND_NOW":"1"})
...
```
Modify the script with the record module, and the script modified is below:
```python
# path: ./test/fastbin
from pwn import *
# p = process('./fast', env={"LD_BIND_NOW":"1"})
p = process('./record_ptrace ./fast', shell=True, env={"LD_BIND_NOW":"1"})
...
```
### Replay the Exploit Process

The script directory is in the "./test/fastbin/", so you should create a new analysis project in this directory.
```python
import sys
sys.path.append("../../source") # to set the path which the replayer exist in
from replayer import Replayer

r = Replayer('./fast', './syscalls.record', './maps', '2.23', new_syscall=True)
r.enable_analysis(["call_analysis", "heap_analysis", "shellcode_analysis", "got_analysis", "leak_analysis"]) # you can choose some analysis enabled
rr.do_analysis() # start analysis
rr.generate_report() # generate the visualization report
```

### 分析
#### 已经实现
1. got表分析
2. 堆分析（部分）
3. 信息泄露分析
4. 函数调用分析（部分）
5. 控制流分析

#### 使用方法
还没有在replayer.py里面添加binding, 直接导入然后实例化，调用`do_analysis`即可。  
部分结果记录在类的变量中，暂时还没有确定最终可视化的表现形式。




## 设计思路
1. 去随机化，使程序的运行结果固定不变。但是即使每次运行中的同一时刻其状态（寄存器、内存）都是固定不变的，我们也很难对他做分析，唯一方法是用调试器获得上下文，分析中的数据不好保存，实现起来也未必比记录+重放简单，再加上分析时几乎必须中止程序运行，可能导致问题。
2. 记录程序的外部输入和初始状态，用于重放。使用angr+unicorn进行重放。
3. 此时我们能够到达记录的那一次执行中的任意状态。到达目标状态然后获取数据，即可分析。